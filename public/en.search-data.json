{"/cpu-scheduling/":{"data":{"":" Scheduling Scheduling Algorithms "},"title":"CPU Scheduling"},"/cpu-scheduling/scheduling-algorithms/":{"data":{"":" First Come First Serve Shortest Job First Shortest Remaining Time First Priority Scheduling Round Robin Multilevel Queues Scheduling Multilevel Feedback Queues Scheduling "},"title":"Scheduling Algorithms"},"/cpu-scheduling/scheduling-algorithms/fcfs/":{"data":{"":"","first-come-first-served-fcfs-scheduling#First-Come, First-Served (FCFS) Scheduling":"Definition: FCFS is the simplest CPU scheduling algorithm where the process that arrives first in the ready queue is scheduled first.\nKey Features:\nQueue Type: FIFO (First In, First Out) Type: Non-preemptive Execution Rule: The CPU is assigned to the process at the head of the queue. Drawback: Convoy effect — short processes may wait long times behind longer ones, causing low CPU and device utilization. Waiting Time: Can be high and varies if burst times differ significantly. ","gantt-chart-example#Gantt Chart Example":"Given: Process Arrival Time Burst Time P1 0 5 P2 1 3 P3 2 8 P4 3 6 Assumption All arrive in order: P1 → P2 → P3 → P4 FCFS ignores arrival time if they’re queued. Gantt Chart gantt title FCFS Process Scheduling dateFormat X axisFormat %s section Process Execution P1 (Burst: 5) :p1, 0, 5 P2 (Burst: 3) :p2, 5, 8 P3 (Burst: 8) :p3, 8, 16 P4 (Burst: 6) :p4, 16, 22 Calculations Process Arrival Time Burst Time Start Time Completion Time Waiting Time Turnaround Time P1 0 5 0 5 0 5 P2 1 3 5 8 4 7 P3 2 8 8 16 6 14 P4 3 6 16 22 13 19 Averages Average Waiting Time = (0 + 4 + 6 + 13) / 4 = 5.75 Average Turnaround Time = (5 + 7 + 14 + 19) / 4 = 11.25 This demonstrates how FCFS can lead to high waiting times especially when short processes follow long ones."},"title":"FCFS"},"/cpu-scheduling/scheduling/":{"data":{"":"","cpu-scheduler#CPU Scheduler":"CPU Scheduler When the CPU becomes idle, the operating system must select one of the processes in the ready queue to execute next. This selection is done by the short-term scheduler, also called the CPU scheduler. It picks a process from memory that is ready to run and calls the dispatcher to allocate the CPU to that process. The ready queue may be implemented using different data structures like FIFO queues, trees, or unordered linked lists. Each entry in the ready queue is usually a process control block (PCB) representing a process.","dispatcher#Dispatcher":"The dispatcher is a part of the kernel responsible for switching the CPU from the currently running process to the one chosen by the CPU scheduler. This involves three key tasks:\nSaving the context of the current process and restoring the context of the new process Switching from kernel mode to user mode Jumping to the appropriate instruction in the new process to resume execution The total time required to perform this switch is known as dispatch latency.\nsequenceDiagram participant CPU participant Process A participant Scheduler participant Process B Process A-\u003e\u003eCPU: Currently running CPU-\u003e\u003eScheduler: Becomes idle or interrupted Scheduler-\u003e\u003eProcess B: Selects next process Scheduler-\u003e\u003eCPU: Calls dispatcher CPU-\u003e\u003eProcess A: Saves context CPU-\u003e\u003eProcess B: Restores context and runs ","preemptive-and-non-preemptive-scheduling#Preemptive and Non-Preemptive Scheduling":"Scheduling can be either preemptive or non-preemptive depending on when the CPU is taken away from a process.\nIf a process moves from running to waiting (for example, during an I/O request) or terminates, the scheduler makes a decision without forcing an interruption. This is non-preemptive scheduling.\nIf a process moves from running to ready (due to an interrupt) or from waiting to ready (for example, I/O completion), then the currently running process may be interrupted to allow another to run. This is preemptive scheduling.","scheduling-criteria#Scheduling Criteria":"CPU utilization measures how effectively the CPU is being used. The goal is to keep it busy as much as possible. In real systems, CPU utilization ranges from 40% on lightly loaded systems to 90% in heavily used environments.\nThroughput refers to the number of processes completed per unit of time. A higher throughput indicates more work is being done, and is desirable.\nTurnaround time is the total time from when a process is submitted to when it is completed. It includes time spent in memory allocation, waiting in the ready queue, executing on the CPU, and performing I/O. Minimizing turnaround time improves system responsiveness.\nWaiting time is the amount of time a process spends waiting in the ready queue before execution. Reducing waiting time increases CPU efficiency and ensures quicker processing of tasks.\nResponse time is the interval between the submission of a request and the system’s first response. It does not include the time taken to complete the request, only the time to begin processing. Lower response time makes the system appear faster to users"},"title":"Scheduling"},"/deadlock/":{"data":{"":" Deadlock Problem Resource Allocation Graphs Deadlock Handling "},"title":"Deadlock"},"/deadlock/deadlock-handling/":{"data":{"":" Deadlock Prevention Dealock Avoidance Dealock Detection Dealock Recovery "},"title":"Deadlock Handling"},"/exec-family/":{"data":{"":"","execl#execl()":"Replaces current process with a new one using a path and a list of arguments\nint execl(const char *path, const char *arg, ..); Return Values:\nSuccess: No return Error: -1 Example:\nexecl(\"/bin/ls\", \"ls\", \"-l\", NULL); ","execle#execle()":"Like execl() but allows specifying a custom environment\nint execle(const char *path, const char *arg, .., char * const envp[]); Return Values:\nSuccess: No return Error: -1 Example:\nchar *env[] = { \"MYVAR=VALUE\", NULL }; execle(\"/bin/ls\", \"ls\", \"-l\", NULL, env); ","execlp#execlp()":"Like execl() but searches PATH for the executable\nint execlp(const char *file, const char *arg, ..); Return Values:\nSuccess: No return Error: -1 Example:\nexeclp(\"ls\", \"ls\", \"-l\", NULL); ","execv#execv()":"Replaces current process using a path and an argument vector (array)\nint execv(const char *path, char *const argv[]); Return Values:\nSuccess: No return Error: -1 Example:\nchar *args[] = { \"ls\", \"-l\", NULL }; execv(\"/bin/ls\", args); ","execvp#execvp()":"Like execv() but searches PATH for the executable\nint execvp(const char *file, char *const argv[]); Return Values:\nSuccess: No return Error: -1 Example:\nchar *args[] = { \"ls\", \"-l\", NULL }; execvp(\"ls\", args); ","execvpe#execvpe()":"Like execvp() but also allows specifying a custom environment\nint execvpe(const char *file, char *const argv[], char *const envp[]); Return Values:\nSuccess: No return Error: -1 Example:\nchar *args[] = { \"ls\", \"-l\", NULL }; char *env[] = { \"MYVAR=VALUE\", NULL }; execvpe(\"ls\", args, env); ","library-required#Library Required":"Library Required #include \u003cunistd.h\u003e "},"title":"Exec Family"},"/file-operations/":{"data":{"":"","close#close()":"Closes an open file descriptor.\nint close(int fd); Retrun Value:\nSuccess: 0 Error: -1 Example:\nclose(fd); ","dup#dup()":"Duplicates an existing file descriptor to the lowest*numbered unused one.\nint dup(int oldfd); Retrun Value:\nSuccess: New file descriptor Error: -1 Example:\nint dup_fd = dup(fd); // dup_fd now refers to the same file ","dup2#dup2()":"Duplicates a file descriptor to a specified descriptor number, closing it first if needed.\nint dup2(int oldfd, int newfd); Retrun Value:\nSuccess: New file descriptor Error: -1 Example:\ndup2(fd, STDOUT_FILENO); // redirect standard output to fd ","file-reading-functions#File Reading Functions":"fopen() Opens a file and returns a file pointer to it.\nFILE *fopen(const char *filename, const char *mode); Return Value:\nSuccess: Pointer to FILE Error: NULL Example:\nFILE *fp = fopen(\"example.txt\", \"r\"); fclose() Closes a previously opened file stream.\nint fclose(FILE *stream); n Return Value:\nSuccess: 0 Error: EOF Example:\nfclose(fp); fgets() Reads a string from a file, stopping at newline or EOF.\nchar *fgets(char *str, int n, FILE *stream); Return Value:\nSuccess: str Error or EOF: NULL Example:\nchar line[256]; fgets(line, sizeof line, fp); fgetc() Reads a single character from a file.\nint fgetc(FILE *stream); Return Value:\nSuccess: Character as an unsigned char cast to int Error or EOF: EOF Example:\nint ch = fgetc(fp); // returns int, not char fread() Reads binary data from a file stream.\nsize_t fread(void *ptr, size_t size, size_t count, FILE *stream); Return Value:\nNumber of full elements successfully read Example:\nint block[512]; size_t n = fread(block, 1, sizeof block, fp); fscanf() Reads formatted input from a file stream.\nint fscanf(FILE *stream, const char *format, ...); Return Value:\nNumber of items successfully read and assigned EOF if input failure occurs before any conversion Example:\nint x, y; fscanf(fp, \"%d %d\", \u0026x, \u0026y); feof() Checks whether the end-of-file indicator is set.\nint feof(FILE *stream); Return Value:\nNon-zero if EOF indicator is set 0 otherwise Example:\nif (feof(fp)) { /* reached end-of-file */ } ferror() Checks whether a file stream has an error.\nint ferror(FILE *stream); Return Value:\nNon-zero if an error occurred 0 otherwise Example:\nif (ferror(fp)) { /* handle stream error */ } ","file-writing-functions#File Writing Functions":"fprintf() Writes formatted output to a file stream.\nint fprintf(FILE *stream, const char *format, ...); Return Value:\nNumber of characters printed Negative number on error Example:\nfprintf(fp, \"Value = %d\\n\", 42); fputs() Writes a null-terminated string to a file.\nint fputs(const char *str, FILE *stream); Return Value:\nSuccess: Non-negative value Error: EOF Example:\nfputs(\"Line of text\\n\", fp); fputc() Writes a single character to a file.\nint fputc(int c, FILE *stream); Return Value:\nSuccess: Character written (as unsigned char cast to int) Error: EOF Example:\nfputc('A', fp); fwrite() Writes binary data to a file stream.\nsize_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream); Return Value:\nNumber of full elements successfully written Example:\nfwrite(block, 1, sizeof block, fp); fflush() Flushes a file’s output buffer to disk.\nint fflush(FILE *stream); Return Value:\nSuccess: 0 Error: EOF Example:\nfflush(fp); // force buffered output to disk ","libraries-required#Libraries Required":"Libraries Required #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e ","open#open()":"Opens a file and returns a file descriptor for it.\nint open(const char *pathname, int flags, mode_t mode); Retrun Value:\nSuccess: File descriptor Error: -1 Example:\nint fd = open(\"example.txt\", O_RDONLY); ","printf#printf()":"Writes formatted output to standard output.\nint printf(const char *format, ...); Return Value:\nNumber of characters printed Negative value if an output error occurs Examples:\n// Printing an integer int x = 10; printf(\"x = %d\\n\", x); // Printing a float float f = 3.14; printf(\"f = %.2f\\n\", f); // Printing a character char c = 'A'; printf(\"Character: %c\\n\", c); // Printing a string char str[] = \"Hello\"; printf(\"String: %s\\n\", str); // Printing multiple values int id = 101; char grade = 'A'; float marks = 89.5; printf(\"ID: %d, Grade: %c, Marks: %.1f\\n\", id, grade, marks); // Printing hexadecimal and octal int num = 255; printf(\"Hex: %x, Octal: %o\\n\", num, num); // Printing a pointer address int *ptr = \u0026x; printf(\"Address: %p\\n\", ptr); ","read#read()":"Reads data from a file descriptor into a buffer\nssize_t read(int fd, void *buf, size_t count); Retrun Value:\nSuccess: Number of bytes read Error: -1 Example:\nchar buf[128]; ssize_t nread = read(fd, buf, sizeof buf); ","scanf#scanf()":"Reads formatted input from standard input.\nint scanf(const char *format, ...); Return Value:\nNumber of items successfully read and assigned EOF if input failure occurs before any conversion Examples:\n// Reading an integer int x; scanf(\"%d\", \u0026x); // Reading a float float f; scanf(\"%f\", \u0026f); // Reading a character char c; scanf(\" %c\", \u0026c); // space before %c to skip whitespace // Reading a string char str[100]; scanf(\"%s\", str); // stops at first whitespace // Reading multiple values int a, b; scanf(\"%d %d\", \u0026a, \u0026b); // Reading a double double d; scanf(\"%lf\", \u0026d); // Reading formatted values into different types int id; char grade; float marks; scanf(\"%d %c %f\", \u0026id, \u0026grade, \u0026marks); ","types#Types":" size_t // is a unsigned integer type used to represent the number of bytes read or written ssize_t // is a signed integer type used to represent the number of bytes read or written FILE* // pointer to struct that represent file stream ","write#write()":"Writes data from a buffer to a file descriptor.\nssize_t write(int fd, const void *buf, size_t count); Retrun Value:\nSuccess: Number of bytes written Error: -1 Example:\nconst char *msg = \"Hello\\n\"; ssize_t nwritten = write(fd, msg, strlen(msg)); "},"title":"File Operations"},"/pipes--fifos/":{"data":{"":"","libraries-required#Libraries Required":"Libraries Required #include \u003cunistd.h\u003e #include \u003csys/stat.h\u003e ","mkfifo#mkfifo()":"Creates a named pipe (FIFO) special file that can be used for inter-process communication\nint mkfifo(const char *pathname, mode_t mode); Return Value:\nSuccess: 0 Error: -1 Modes:\nOctal Symbolic Description 0400 r– — — Read by owner 0200 -w- — — Write by owner 0600 rw- — — Read/Write by owner 0040 — r– — Read by group 0020 — -w- — Write by group 0060 — rw- — Read/Write by group 0004 — — r– Read by others 0002 — — -w- Write by others 0006 — — rw- Read/Write by others 0666 rw- rw- rw- Read/Write by all (owner/group/others) 0644 rw- r– r– Owner RW, Group R, Others R Tip\nOwner: The user who created the file and has primary control over it Group: Set of different users Others: Users neither owner nor group Example:\nmkfifo(\"mypipe\", 0666); int fd = open(\"mypipe\", O_WRONLY); write(fd, \"Hi\", 2); ","pipe#pipe()":"Creates a unidirectional data channel (pipe) using a pair of file descriptors for reading and writing\nint pipe(int pipefd[2]); Return Value:\nSuccess: 0 Error: -1 Example:\nint fd[2]; pipe(fd); if (fork() == 0) { close(fd[0]); write(fd[1], \"Hello\", 5); _exit(0); } else { close(fd[1]); char buf[6] = {0}; read(fd[0], buf, 5); printf(\"Parent read: %s\\n\", buf); } "},"title":"Pipes \u0026 FIFOs"},"/process-control/":{"data":{"":"","_exit#_exit()":"Immediately terminates the process without flushing stdio buffers or calling cleanup handlers.\nvoid _exit(int status); Return Value:\nDoes not return Example:\n_exit(0); ","exit#exit()":"Terminates the calling process and performs cleanup (e.g., flushes stdio buffers).\nvoid exit(int status); Return Value:\nDoes not return Example:\nexit(0); ","fork#fork()":"fork() Creates a new child process by duplicating the calling (parent) process.\npid_t fork(void); Return Value:\nParent: child’s PID (positive) Child: 0 Error: -1 Example:\npid_t pid = fork(); if (pid == 0) { printf(\"Child process\\n\"); _exit(0); } else { printf(\"Parent process, child PID: %d\\n\", pid); } ","macros#MACROS":"WIFEXITED Returns true if the child terminated normally (via exit() or _exit()).\nWIFEXITED(status) Return Value:\nTrue if child terminated normally Example:\nint status; wait(\u0026status); if (WIFEXITED(status)) { printf(\"Child exited normally\\n\"); } WEXITSTATUS Returns the exit status code of the child (only valid if WIFEXITED(status) is true).\nWEXITSTATUS(status) Return Value:\nReturn code when WIFEXITED is true Example:\nif (WIFEXITED(status)) { int code = WEXITSTATUS(status); printf(\"Exit code: %d\\n\", code); } WIFSIGNALED Returns true if the child terminated due to an uncaught signal.\nWIFSIGNALED(status) Return Value:\nTrue if child terminated by signal Example:\nif (WIFSIGNALED(status)) { printf(\"Child killed by signal\\n\"); } ","wait#wait()":"Suspends execution of the calling process until any of its child processes terminates.\npid_t wait(int *status); Return Value:\nSuccess: PID of terminated child Error: -1 Example:\nint status; wait(\u0026status); ","waitpid#waitpid()":"Waits for a specific child process or set of children to terminate.\npid_t waitpid(pid_t pid, int *status, int options); Return Value:\nSuccess: PID of child Error: -1 With WNOHANG and no children ready: 0 Example:\nint status; pid_t child = fork(); if (child == 0) _exit(5); waitpid(child, \u0026status, 0); "},"title":"Process Control"},"/process-synchronization/":{"data":{"":" Shared Memory Producer Consumer Problem Critical Section Problem Semaphores Bounded Buffer Problem Reader Writer Problem Dining Philosipher Problem Sleeping Barber Problem "},"title":"Process Synchronization"},"/process-synchronization/reader-writer-problem/":{"data":{"readers-writers-problem#Readers Writers Problem":"Readers Writers Problem"},"title":"Reader Writer Problem"},"/process-synchronization/shared-memory/":{"data":{"":"","concept#Concept":"Concept Shared memory is an inter-process communication (IPC) mechanism where multiple processes share a region of memory. This region is created by one process using shmget() and then mapped into the address space of other processes via shmat().\nThe OS typically isolates memory between processes. However, shared memory explicitly bypasses this restriction by mutual agreement between processes. Once attached, processes can directly read from and write to the shared region. This memory is not controlled or interpreted by the OS—the processes using it define the format, meaning, and structure of the data. Synchronization is critical: the OS does not prevent race conditions. It’s up to the processes to ensure safe access—typically by using semaphores or mutexes. This makes shared memory very fast for IPC, since there’s no copying of data between processes, but it also requires careful coordination.","race-condition#Race Condition":"A race condition occurs when the outcome of a program depends on the timing or sequence of uncontrollable events like context switches between threads or processes. It happens when:\nTwo or more threads/processes access shared data simultaneously. At least one of them is modifying the data. There is no proper synchronization to control the access. This can lead to unexpected behavior, data corruption, or crashes.","race-condition-scenario#Race Condition Scenario":" sequenceDiagram participant Thread A participant Shared Memory participant Thread B Thread A-\u003e\u003eShared Memory: Read value (x = 5) Thread B-\u003e\u003eShared Memory: Read value (x = 5) Thread A-\u003e\u003eThread A: Increment x (x = 6) Thread B-\u003e\u003eThread B: Increment x (x = 6) Thread A-\u003e\u003eShared Memory: Write x = 6 Thread B-\u003e\u003eShared Memory: Write x = 6 Note over Shared Memory: Final value 7 but is 6 (race condition) In the above diagram, both threads read the same initial value and update it without knowing the other thread’s action. The final result does not reflect both increments, demonstrating a race condition."},"title":"Shared Memory"},"/semaphores/":{"data":{"":"","library-required#Library Required":"Library Required #include \u003csemaphore.h\u003e ","sem_close#sem_close()":"Closes a named semaphore descriptor without removing the semaphore.\nint sem_close(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 Example:\nsem_close(sem); ","sem_destroy#sem_destroy()":"Destroys an unnamed semaphore, freeing associated resources.\nint sem_destroy(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 Example:\nsem_destroy(\u0026sem_local); ","sem_getvalue#sem_getvalue()":"Retrieves the current value of the semaphore.\nint sem_getvalue(sem_t *sem, int *sval); Return Value:\nSuccess: 0 Error: -1 Example:\nint val; sem_getvalue(sem, \u0026val); ","sem_init#sem_init()":"Initializes an unnamed semaphore for use within a process or between processes.\nint sem_init(sem_t *sem, int pshared, unsigned int value); Return Value:\nSuccess: 0 Error: -1 Example:\nsem_t sem_local; sem_init(\u0026sem_local, 0, 1); ","sem_open#sem_open()":"Opens or creates a named semaphore and returns a pointer to it.\nsem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); Return Value:\nSuccess: Pointer to semaphore Error: SEM_FAILED Example:\nsem_t *sem = sem_open(\"/mysem\", O_CREAT | O_EXCL, 0644, 2); ","sem_post#sem_post()":"Increments (unlocks) the semaphore, potentially waking a waiting thread.\nint sem_post(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 Example:\nsem_post(sem); ","sem_trywait#sem_trywait()":"Tries to decrement the semaphore without blocking; fails if the value is zero.\nint sem_trywait(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 Example:\nif (sem_trywait(sem) == -1) { // handle failure without blocking } ","sem_unlink#sem_unlink()":"Removes a named semaphore from the system\nint sem_unlink(const char *name); Return Value:\nSuccess: 0 Error: -1 Example:\nsem_unlink(\"/mysem\"); ","sem_wait#sem_wait()":"Decrements (locks) the semaphore, blocking if its value is zero.\nint sem_wait(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 Example:\nsem_wait(sem); ","types#Types":" sem_t // unique identifier for a semaphore "},"title":"Semaphore"},"/shared-memory/":{"data":{"":"","libraries-required#Libraries Required":"Libraries Required #include \u003csys/ipc.h\u003e #include \u003csys/shm.h\u003e #include \u003csys/sem.h\u003e #include \u003csys/mman.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e ","memory-mapping#Memory Mapping":"mmap() Maps a file or anonymous memory into the process’s address space\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); Return Value:\nSuccess: Pointer to mapped area Error: MAP_FAILED Example:\nint fd = open(\"file.txt\", O_RDWR); char *addr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); Options Flag / Protection Description PROT_READ Pages can be read PROT_WRITE Pages can be written MAP_SHARED Updates visible to other processes mapping same region MAP_PRIVATE Copy-on-write; changes not visible to other processes MAP_ANONYMOUS Mapping is not backed by any file (used with -1 as fd) MAP_FAILED Return value on error munmap() Unmaps a previously mapped memory region from the address space\nint munmap(void *addr, size_t length); Return Value:\nSuccess: 0 Error: -1 Example:\nmunmap(addr, 4096); ","semget#semget()":"Creates a new semaphore set or accesses an existing one\nint semget(key_t key, int nsems, int semflg); Return Value:\nSuccess: Semaphore set ID Error: -1 Example:\nint semid = semget(IPC_PRIVATE, 1, IPC_CREAT | 0666); Options Option Description IPC_CREAT Create the semaphore set if it does not exist IPC_EXCL Fail if it exists (used with IPC_CREAT) 0666 Read \u0026 write permissions ","semop#semop()":"Performs one or more atomic operations on semaphores\nint semop(int semid, struct sembuf *sops, size_t nsops); Return Value:\nSuccess: 0 Error: -1 Example:\nsops[0].sem_num = 0; sops[0].sem_op = -1; sops[0].sem_flg = 0; semop(semid, sops, 1); ","shmat#shmat()":"Attaches a shared memory segment to the process’s address space\nvoid *shmat(int shmid, const void *shmaddr, int shmflg); Return Value:\nSuccess: Pointer to shared memory segment Error: -1 Example:\nchar *data = (char *)shmat(shmid, NULL, 0); ","shmctl#shmctl()":"Performs control operations on a shared memory segment (eg., remove, get info).\nint shmctl(int shmid, int cmd, struct shmid_ds *buf); Return Value:\nSuccess: 0 Error: -1 Example:\nshmctl(shmid, IPC_RMID, NULL); Options Command Description IPC_STAT Get current segment status into shmid_ds struct IPC_SET Set permissions and other fields from shmid_ds IPC_RMID Remove the segment ","shmdt#shmdt()":"Detaches a shared memory segment from the process’s address space\nint shmdt(const void *shmaddr); Return Value:\nSuccess: 0 Error: -1 Example:\nshmdt(data); ","shmget#shmget()":"Allocates or accesses a shared memory segment using a key\nint shmget(key_t key, size_t size, int shmflg); Return Value:\nSuccess: Shared memory segment ID Error: -1 Example:\nint shmid = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0666); Options Option Description IPC_CREAT Create the segment if it does not exist IPC_EXCL Fail if segment exists (used with IPC_CREAT) 0666 Read \u0026 write permissions for all (standard mode) "},"title":"Shared Memory"},"/threading/":{"data":{"":"","library-required#Library Required":"","pthread_attr_destroy#pthread_attr_destroy()":"Library Required #include \u003cpthread.h\u003e Types pthread_t // uniquely identify a thread in POSIX thread programming pthread_attr_t // uniquely identify a thread attributes in POSIX pthread_create() Creates a new thread and starts executing the specified routine in parallel\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg); Return Value:\nSuccess: 0 Error: Error number Example:\nvoid* print_msg(void* arg) { printf(\"Thread: %s\\n\", (char*)arg); return NULL; } pthread_t tid; pthread_create(\u0026tid, NULL, print_msg, \"Hello from thread\"); pthread_join() Waits for the specified thread to terminate and optionally collects its return value\nint pthread_join(pthread_t thread, void **retval); Return Value:\nSuccess: 0 Error: Error number Example:\nvoid* thread_func(void* arg) { return (void*)42; } pthread_t tid; pthread_create(\u0026tid, NULL, thread_func, NULL); void* retval; pthread_join(tid, \u0026retval); printf(\"Thread returned: %ld\\n\", (long)retval); pthread_detach() Marks a thread as detached so its resources are automatically released on termination\nint pthread_detach(pthread_t thread); Return Value:\nSuccess: 0 Error: Error number Example:\nvoid* detached_func(void* arg) { pthread_exit(NULL); } pthread_t tid; pthread_create(\u0026tid, NULL, detached_func, NULL); pthread_detach(tid); pthread_exit() Terminates the calling thread and optionally returns a value to any joining thread\nvoid pthread_exit(void *retval); Return Value:\nDoes not return Example:\nvoid* thread_func(void* arg) { pthread_exit(\"Finished\"); return NULL; } pthread_t tid; pthread_create(\u0026tid, NULL, thread_func, NULL); pthread_self() Returns the thread ID of the calling thread\npthread_t pthread_self(void); Return Value:\nThe ID of the calling thread Example:\nvoid* thread_func(void* arg) { printf(\"Thread ID: %lu\\n\", pthread_self()); return NULL; } pthread_t tid; pthread_create(\u0026tid, NULL, thread_func, NULL); pthread_attr_init() Initializes a thread attribute object with default values\nint pthread_attr_init(pthread_attr_t *attr); Return Value:\nSuccess: 0 Error: Error number Example:\npthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_destroy() Destroys a thread attribute object and frees associated resources\nint pthread_attr_destroy(pthread_attr_t *attr); Return Value:\nSuccess: 0 Error: Error number Example:\npthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_destroy(\u0026attr); ","pthread_attr_init#pthread_attr_init()":"","pthread_create#pthread_create()":"","pthread_detach#pthread_detach()":"","pthread_exit#pthread_exit()":"","pthread_join#pthread_join()":"","pthread_self#pthread_self()":"","thread-attr-settergetter#Thread Attr Setter/Getter":"These functions are used to set and get properties of a pthread_attr_t object before creating a thread.\npthread_attr_setdetachstate / pthread_attr_getdetachstate Sets or gets the detach state (joinable or detached).\nint pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); Values: PTHREAD_CREATE_JOINABLE (default) · PTHREAD_CREATE_DETACHED\nExample\npthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_DETACHED); int state; pthread_attr_getdetachstate(\u0026attr, \u0026state); // state now holds the detach flag pthread_attr_destroy(\u0026attr); pthread_attr_setschedpolicy / pthread_attr_getschedpolicy Sets or gets the scheduling policy.\nint pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy); int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy); Policies: SCHED_OTHER (default) · SCHED_FIFO · SCHED_RR\nExample\npthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_setschedpolicy(\u0026attr, SCHED_FIFO); int policy; pthread_attr_getschedpolicy(\u0026attr, \u0026policy); // policy now SCHED_FIFO pthread_attr_destroy(\u0026attr); pthread_attr_setschedparam / pthread_attr_getschedparam Sets or gets scheduling parameters (e.g., priority).\nint pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param); int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param); Example\npthread_attr_t attr; pthread_attr_init(\u0026attr); struct sched_param sp = { .sched_priority = 20 }; pthread_attr_setschedparam(\u0026attr, \u0026sp); struct sched_param out; pthread_attr_getschedparam(\u0026attr, \u0026out); // out.sched_priority == 20 pthread_attr_destroy(\u0026attr); pthread_attr_setinheritsched / pthread_attr_getinheritsched Sets or gets whether the thread inherits or explicitly uses scheduling attributes.\nint pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit); int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit); Values: PTHREAD_INHERIT_SCHED · PTHREAD_EXPLICIT_SCHED\nExample\npthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_setinheritsched(\u0026attr, PTHREAD_EXPLICIT_SCHED); int inherit; pthread_attr_getinheritsched(\u0026attr, \u0026inherit); // inherit now explicit pthread_attr_destroy(\u0026attr); pthread_attr_setstacksize / pthread_attr_getstacksize Sets or gets the thread stack size.\nint pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize); int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize); Example\npthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_setstacksize(\u0026attr, 1024 * 1024); // 1 MB size_t sz; pthread_attr_getstacksize(\u0026attr, \u0026sz); // sz == 1048576 pthread_attr_destroy(\u0026attr); pthread_attr_setstack / pthread_attr_getstack Sets or gets both stack address and size.\nint pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize); int pthread_attr_getstack(const pthread_attr_t *attr, void **stackaddr, size_t *stacksize); Example\nchar stack_area[64 * 1024]; // 64 KB buffer pthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_setstack(\u0026attr, stack_area, sizeof stack_area); void *addr; size_t sz; pthread_attr_getstack(\u0026attr, \u0026addr, \u0026sz); // addr == stack_area, sz == 65536 pthread_attr_destroy(\u0026attr); ","types#Types":""},"title":"Threading"},"/virtual-memory/page-replacement-algorithm/":{"data":{"":" FIFO Optimal Page Replacement Least Recently Used Clock "},"title":"Page Repalcement Algorithm"}}