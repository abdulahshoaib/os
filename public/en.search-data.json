{"/exec-family/":{"data":{"":"","execl#execl()":"Replaces current process with a new one using a path and a list of arguments\nint execl(const char *path, const char *arg, ..); Return Values:\nSuccess: No return Error: -1 Example:\nexecl(\"/bin/ls\", \"ls\", \"-l\", NULL); ","execle#execle()":"Like execl() but allows specifying a custom environment\nint execle(const char *path, const char *arg, .., char * const envp[]); Return Values:\nSuccess: No return Error: -1 Example:\nchar *env[] = { \"MYVAR=VALUE\", NULL }; execle(\"/bin/ls\", \"ls\", \"-l\", NULL, env); ","execlp#execlp()":"Like execl() but searches PATH for the executable\nint execlp(const char *file, const char *arg, ..); Return Values:\nSuccess: No return Error: -1 Example:\nexeclp(\"ls\", \"ls\", \"-l\", NULL); ","execv#execv()":"Replaces current process using a path and an argument vector (array)\nint execv(const char *path, char *const argv[]); Return Values:\nSuccess: No return Error: -1 Example:\nchar *args[] = { \"ls\", \"-l\", NULL }; execv(\"/bin/ls\", args); ","execvp#execvp()":"Like execv() but searches PATH for the executable\nint execvp(const char *file, char *const argv[]); Return Values:\nSuccess: No return Error: -1 Example:\nchar *args[] = { \"ls\", \"-l\", NULL }; execvp(\"ls\", args); ","execvpe#execvpe()":"Like execvp() but also allows specifying a custom environment\nint execvpe(const char *file, char *const argv[], char *const envp[]); Return Values:\nSuccess: No return Error: -1 Example:\nchar *args[] = { \"ls\", \"-l\", NULL }; char *env[] = { \"MYVAR=VALUE\", NULL }; execvpe(\"ls\", args, env); ","library-used#Library Used":"Library Used #include \u003cunistd.h\u003e "},"title":"_index"},"/file-operations/":{"data":{"":"","close#close()":"Closes an open file descriptor.\nint close(int fd); Retrun Value:\nSuccess: 0 Error: -1 Example:\nclose(fd); ","dup#dup()":"Duplicates an existing file descriptor to the lowest*numbered unused one.\nint dup(int oldfd); Retrun Value:\nSuccess: New file descriptor Error: -1 Example:\nint dup_fd = dup(fd); // dup_fd now refers to the same file ","dup2#dup2()":"Duplicates a file descriptor to a specified descriptor number, closing it first if needed.\nint dup2(int oldfd, int newfd); Retrun Value:\nSuccess: New file descriptor Error: -1 Example:\ndup2(fd, STDOUT_FILENO); // redirect standard output to fd ","file-reading-functions#File Reading Functions":"fopen() Opens a file and returns a file pointer to it.\nFILE *fopen(const char *filename, const char *mode); Return Value:\nSuccess: Pointer to FILE Error: NULL Example:\nFILE *fp = fopen(\"example.txt\", \"r\"); fclose() Closes a previously opened file stream.\nint fclose(FILE *stream); n Return Value:\nSuccess: 0 Error: EOF Example:\nfclose(fp); fgets() Reads a string from a file, stopping at newline or EOF.\nchar *fgets(char *str, int n, FILE *stream); Return Value:\nSuccess: str Error or EOF: NULL Example:\nchar line[256]; fgets(line, sizeof line, fp); fgetc() Reads a single character from a file.\nint fgetc(FILE *stream); Return Value:\nSuccess: Character as an unsigned char cast to int Error or EOF: EOF Example:\nint ch = fgetc(fp); // returns int, not char fread() Reads binary data from a file stream.\nsize_t fread(void *ptr, size_t size, size_t count, FILE *stream); Return Value:\nNumber of full elements successfully read Example:\nint block[512]; size_t n = fread(block, 1, sizeof block, fp); fscanf() Reads formatted input from a file stream.\nint fscanf(FILE *stream, const char *format, ...); Return Value:\nNumber of items successfully read and assigned EOF if input failure occurs before any conversion Example:\nint x, y; fscanf(fp, \"%d %d\", \u0026x, \u0026y); feof() Checks whether the end-of-file indicator is set.\nint feof(FILE *stream); Return Value:\nNon-zero if EOF indicator is set 0 otherwise Example:\nif (feof(fp)) { /* reached end-of-file */ } ferror() Checks whether a file stream has an error.\nint ferror(FILE *stream); Return Value:\nNon-zero if an error occurred 0 otherwise Example:\nif (ferror(fp)) { /* handle stream error */ } ","file-writing-functions#File Writing Functions":"fprintf() Writes formatted output to a file stream.\nint fprintf(FILE *stream, const char *format, ...); Return Value:\nNumber of characters printed Negative number on error Example:\nfprintf(fp, \"Value = %d\\n\", 42); fputs() Writes a null-terminated string to a file.\nint fputs(const char *str, FILE *stream); Return Value:\nSuccess: Non-negative value Error: EOF Example:\nfputs(\"Line of text\\n\", fp); fputc() Writes a single character to a file.\nint fputc(int c, FILE *stream); Return Value:\nSuccess: Character written (as unsigned char cast to int) Error: EOF Example:\nfputc('A', fp); fwrite() Writes binary data to a file stream.\nsize_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream); Return Value:\nNumber of full elements successfully written Example:\nfwrite(block, 1, sizeof block, fp); fflush() Flushes a file’s output buffer to disk.\nint fflush(FILE *stream); Return Value:\nSuccess: 0 Error: EOF Example:\nfflush(fp); // force buffered output to disk ","libraries-used#Libraries Used":"Libraries Used #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e ","open#open()":"Opens a file and returns a file descriptor for it.\nint open(const char *pathname, int flags, mode_t mode); Retrun Value:\nSuccess: File descriptor Error: -1 Example:\nint fd = open(\"example.txt\", O_RDONLY); ","printf#printf()":"Writes formatted output to standard output.\nint printf(const char *format, ...); Return Value:\nNumber of characters printed Negative value if an output error occurs Examples:\n// Printing an integer int x = 10; printf(\"x = %d\\n\", x); // Printing a float float f = 3.14; printf(\"f = %.2f\\n\", f); // Printing a character char c = 'A'; printf(\"Character: %c\\n\", c); // Printing a string char str[] = \"Hello\"; printf(\"String: %s\\n\", str); // Printing multiple values int id = 101; char grade = 'A'; float marks = 89.5; printf(\"ID: %d, Grade: %c, Marks: %.1f\\n\", id, grade, marks); // Printing hexadecimal and octal int num = 255; printf(\"Hex: %x, Octal: %o\\n\", num, num); // Printing a pointer address int *ptr = \u0026x; printf(\"Address: %p\\n\", ptr); ","read#read()":"Reads data from a file descriptor into a buffer\nssize_t read(int fd, void *buf, size_t count); Retrun Value:\nSuccess: Number of bytes read Error: -1 Example:\nchar buf[128]; ssize_t nread = read(fd, buf, sizeof buf); ","scanf#scanf()":"Reads formatted input from standard input.\nint scanf(const char *format, ...); Return Value:\nNumber of items successfully read and assigned EOF if input failure occurs before any conversion Examples:\n// Reading an integer int x; scanf(\"%d\", \u0026x); // Reading a float float f; scanf(\"%f\", \u0026f); // Reading a character char c; scanf(\" %c\", \u0026c); // space before %c to skip whitespace // Reading a string char str[100]; scanf(\"%s\", str); // stops at first whitespace // Reading multiple values int a, b; scanf(\"%d %d\", \u0026a, \u0026b); // Reading a double double d; scanf(\"%lf\", \u0026d); // Reading formatted values into different types int id; char grade; float marks; scanf(\"%d %c %f\", \u0026id, \u0026grade, \u0026marks); ","types-used#Types Used":" size_t // is a unsigned integer type used to represent the number of bytes read or written ssize_t // is a signed integer type used to represent the number of bytes read or written FILE* // pointer to struct that represent file stream ","write#write()":"Writes data from a buffer to a file descriptor.\nssize_t write(int fd, const void *buf, size_t count); Retrun Value:\nSuccess: Number of bytes written Error: -1 Example:\nconst char *msg = \"Hello\\n\"; ssize_t nwritten = write(fd, msg, strlen(msg)); "},"title":"_index"},"/pipes--fifos/":{"data":{"":"","libraries-used#Libraries Used":"Libraries Used #include \u003cunistd.h\u003e #include \u003csys/stat.h\u003e ","mkfifo#mkfifo()":"Creates a named pipe (FIFO) special file that can be used for inter-process communication\nint mkfifo(const char *pathname, mode_t mode); Return Value:\nSuccess: 0 Error: -1 Modes:\nOctal Symbolic Description 0400 r– — — Read by owner 0200 -w- — — Write by owner 0600 rw- — — Read/Write by owner 0040 — r– — Read by group 0020 — -w- — Write by group 0060 — rw- — Read/Write by group 0004 — — r– Read by others 0002 — — -w- Write by others 0006 — — rw- Read/Write by others 0666 rw- rw- rw- Read/Write by all (owner/group/others) 0644 rw- r– r– Owner RW, Group R, Others R Tip\nOwner: The user who created the file and has primary control over it Group: Set of different users Others: Users neither owner nor group Example:\nmkfifo(\"mypipe\", 0666); int fd = open(\"mypipe\", O_WRONLY); write(fd, \"Hi\", 2); ","pipe#pipe()":"Creates a unidirectional data channel (pipe) using a pair of file descriptors for reading and writing\nint pipe(int pipefd[2]); Return Value:\nSuccess: 0 Error: -1 Example:\nint fd[2]; pipe(fd); if (fork() == 0) { close(fd[0]); write(fd[1], \"Hello\", 5); _exit(0); } else { close(fd[1]); char buf[6] = {0}; read(fd[0], buf, 5); printf(\"Parent read: %s\\n\", buf); } "},"title":"_index"},"/process-control/":{"data":{"":"","_exit#_exit()":"Immediately terminates the process without flushing stdio buffers or calling cleanup handlers.\nvoid _exit(int status); Return Value:\nDoes not return Example:\n_exit(0); ","exit#exit()":"Terminates the calling process and performs cleanup (e.g., flushes stdio buffers).\nvoid exit(int status); Return Value:\nDoes not return Example:\nexit(0); ","fork#fork()":"Creates a new child process by duplicating the calling (parent) process.\npid_t fork(void); Return Value:\nParent: child’s PID (positive) Child: 0 Error: -1 Example:\npid_t pid = fork(); if (pid == 0) { printf(\"Child process\\n\"); _exit(0); } else { printf(\"Parent process, child PID: %d\\n\", pid); } ","library-used#Library Used":"Library Used #include \u003csys/wait.h\u003e ","macros#MACROS":"WIFEXITED Returns true if the child terminated normally (via exit() or _exit()).\nWIFEXITED(status) Return Value:\nTrue if child terminated normally Example:\nint status; wait(\u0026status); if (WIFEXITED(status)) { printf(\"Child exited normally\\n\"); } WEXITSTATUS Returns the exit status code of the child (only valid if WIFEXITED(status) is true).\nWEXITSTATUS(status) Return Value:\nReturn code when WIFEXITED is true Example:\nif (WIFEXITED(status)) { int code = WEXITSTATUS(status); printf(\"Exit code: %d\\n\", code); } WIFSTOPPED Returns true if the child process is currently stopped, not terminated.\nWIFSTOPPED(status) Return Value:\nTrue if child is stopped Example:\nif (WIFSTOPPED(status)) { printf(\"Child is stopped\\n\"); } WIFSIGNALED Returns true if the child terminated due to an uncaught signal.\nWIFSIGNALED(status) Return Value:\nTrue if child terminated by signal Example:\nif (WIFSIGNALED(status)) { printf(\"Child killed by signal\\n\"); } ","wait#wait()":"Suspends execution of the calling process until any of its child processes terminates.\npid_t wait(int *status); Return Value:\nSuccess: PID of terminated child Error: -1 Example:\nint status; wait(\u0026status); ","waitpid#waitpid()":"Waits for a specific child process or set of children to terminate.\npid_t waitpid(pid_t pid, int *status, int options); Return Value:\nSuccess: PID of child Error: -1 With WNOHANG and no children ready: 0 Example:\nint status; pid_t child = fork(); if (child == 0) _exit(5); waitpid(child, \u0026status, 0); "},"title":"_index"},"/semaphores/":{"data":{"":"","sem_close#sem_close()":"Closes a named semaphore descriptor without removing the semaphore.\nint sem_close(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 ","sem_destroy#sem_destroy()":"Destroys an unnamed semaphore, freeing associated resources.\nint sem_destroy(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 ","sem_getvalue#sem_getvalue()":"Retrieves the current value of the semaphore.\nint sem_getvalue(sem_t *sem, int *sval); Return Value:\nSuccess: 0 Error: -1 ","sem_init#sem_init()":"Initializes an unnamed semaphore for use within a process or between processes.\nint sem_init(sem_t *sem, int pshared, unsigned int value); Return Value:\nSuccess: 0 Error: -1 ","sem_open#sem_open()":"sem_open() Opens or creates a named semaphore and returns a pointer to it.\nsem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); Return Value:\nSuccess: Pointer to semaphore Error: SEM_FAILED ","sem_post#sem_post()":"Increments (unlocks) the semaphore, potentially waking a waiting thread.\nint sem_post(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 ","sem_trywait#sem_trywait()":"Tries to decrement the semaphore without blocking; fails if the value is zero.\nint sem_trywait(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 ","sem_unlink#sem_unlink()":"Removes a named semaphore from the system\nint sem_unlink(const char *name); Return Value:\nSuccess: 0 Error: -1 ","sem_wait#sem_wait()":"Decrements (locks) the semaphore, blocking if its value is zero.\nint sem_wait(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 "},"title":"_index"},"/shared-memory/":{"data":{"":"","memory-mapping#Memory Mapping":"mmap() Maps a file or anonymous memory into the process’s address space\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); Return Value:\nSuccess: Pointer to mapped area Error: MAP_FAILED munmap() Unmaps a previously mapped memory region from the address space\nint munmap(void *addr, size_t length); Return Value:\nSuccess: 0 Error: -1 ","semget#semget()":"Creates a new semaphore set or accesses an existing one\nint semget(key_t key, int nsems, int semflg); Return Value:\nSuccess: Semaphore set ID Error: -1 ","semop#semop()":"Performs one or more atomic operations on semaphores\nint semop(int semid, struct sembuf *sops, size_t nsops); Return Value:\nSuccess: 0 Error: -1 ","shmat#shmat()":"Attaches a shared memory segment to the process’s address space\nvoid *shmat(int shmid, const void *shmaddr, int shmflg); Return Value:\nSuccess: Pointer to shared memory segment Error: -1 ","shmctl#shmctl()":"Performs control operations on a shared memory segment (eg., remove, get info).\nint shmctl(int shmid, int cmd, struct shmid_ds *buf); Return Value:\nSuccess: 0 Error: -1 ","shmdt#shmdt()":"Detaches a shared memory segment from the process’s address space\nint shmdt(const void *shmaddr); Return Value:\nSuccess: 0 Error: -1 ","shmget#shmget()":"shmget() Allocates or accesses a shared memory segment using a key\nint shmget(key_t key, size_t size, int shmflg); Return Value:\nSuccess: Shared memory segment ID Error: -1 "},"title":"_index"},"/threading/":{"data":{"":"","library-used#Library Used":"","pthread_attr_destroy#pthread_attr_destroy()":"Library Used #include \u003cpthread\u003e Types pthread_t // uniquely identify a thread in POSIX thread programming pthread_attr_t // uniquely identify a thread attributes in POSIX pthread_create() Creates a new thread and starts executing the specified routine in parallel\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg); Return Value:\nSuccess: 0 Error: Error number Example:\nvoid* print_msg(void* arg) { printf(\"Thread: %s\\n\", (char*)arg); return NULL; } pthread_t tid; pthread_create(\u0026tid, NULL, print_msg, \"Hello from thread\"); pthread_join() Waits for the specified thread to terminate and optionally collects its return value\nint pthread_join(pthread_t thread, void **retval); Return Value:\nSuccess: 0 Error: Error number Example:\nvoid* thread_func(void* arg) { return (void*)42; } pthread_t tid; pthread_create(\u0026tid, NULL, thread_func, NULL); void* retval; pthread_join(tid, \u0026retval); printf(\"Thread returned: %ld\\n\", (long)retval); pthread_detach() Marks a thread as detached so its resources are automatically released on termination\nint pthread_detach(pthread_t thread); Return Value:\nSuccess: 0 Error: Error number Example:\nvoid* detached_func(void* arg) { pthread_exit(NULL); } pthread_t tid; pthread_create(\u0026tid, NULL, detached_func, NULL); pthread_detach(tid); pthread_exit() Terminates the calling thread and optionally returns a value to any joining thread\nvoid pthread_exit(void *retval); Return Value:\nDoes not return Example:\nvoid* thread_func(void* arg) { pthread_exit(\"Finished\"); return NULL; } pthread_t tid; pthread_create(\u0026tid, NULL, thread_func, NULL); pthread_self() Returns the thread ID of the calling thread\npthread_t pthread_self(void); Return Value:\nThe ID of the calling thread Example:\nvoid* thread_func(void* arg) { printf(\"Thread ID: %lu\\n\", pthread_self()); return NULL; } pthread_t tid; pthread_create(\u0026tid, NULL, thread_func, NULL); pthread_attr_init() Initializes a thread attribute object with default values\nint pthread_attr_init(pthread_attr_t *attr); Return Value:\nSuccess: 0 Error: Error number Example:\npthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_destroy() Destroys a thread attribute object and frees associated resources\nint pthread_attr_destroy(pthread_attr_t *attr); Return Value:\nSuccess: 0 Error: Error number Example:\npthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_destroy(\u0026attr); ","pthread_attr_init#pthread_attr_init()":"","pthread_create#pthread_create()":"","pthread_detach#pthread_detach()":"","pthread_exit#pthread_exit()":"","pthread_join#pthread_join()":"","pthread_self#pthread_self()":"","thread-attr-settergetter#Thread Attr Setter/Getter":"These functions are used to set and get properties of a pthread_attr_t object before creating a thread.\npthread_attr_setdetachstate / pthread_attr_getdetachstate Sets or gets the detach state (joinable or detached).\nint pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); Values: PTHREAD_CREATE_JOINABLE (default) · PTHREAD_CREATE_DETACHED\nExample\npthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_DETACHED); int state; pthread_attr_getdetachstate(\u0026attr, \u0026state); // state now holds the detach flag pthread_attr_destroy(\u0026attr); pthread_attr_setschedpolicy / pthread_attr_getschedpolicy Sets or gets the scheduling policy.\nint pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy); int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy); Policies: SCHED_OTHER (default) · SCHED_FIFO · SCHED_RR\nExample\npthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_setschedpolicy(\u0026attr, SCHED_FIFO); int policy; pthread_attr_getschedpolicy(\u0026attr, \u0026policy); // policy now SCHED_FIFO pthread_attr_destroy(\u0026attr); pthread_attr_setschedparam / pthread_attr_getschedparam Sets or gets scheduling parameters (e.g., priority).\nint pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param); int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param); Example\npthread_attr_t attr; pthread_attr_init(\u0026attr); struct sched_param sp = { .sched_priority = 20 }; pthread_attr_setschedparam(\u0026attr, \u0026sp); struct sched_param out; pthread_attr_getschedparam(\u0026attr, \u0026out); // out.sched_priority == 20 pthread_attr_destroy(\u0026attr); pthread_attr_setinheritsched / pthread_attr_getinheritsched Sets or gets whether the thread inherits or explicitly uses scheduling attributes.\nint pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit); int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit); Values: PTHREAD_INHERIT_SCHED · PTHREAD_EXPLICIT_SCHED\nExample\npthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_setinheritsched(\u0026attr, PTHREAD_EXPLICIT_SCHED); int inherit; pthread_attr_getinheritsched(\u0026attr, \u0026inherit); // inherit now explicit pthread_attr_destroy(\u0026attr); pthread_attr_setstacksize / pthread_attr_getstacksize Sets or gets the thread stack size.\nint pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize); int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize); Example\npthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_setstacksize(\u0026attr, 1024 * 1024); // 1 MB size_t sz; pthread_attr_getstacksize(\u0026attr, \u0026sz); // sz == 1048576 pthread_attr_destroy(\u0026attr); pthread_attr_setstack / pthread_attr_getstack Sets or gets both stack address and size.\nint pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize); int pthread_attr_getstack(const pthread_attr_t *attr, void **stackaddr, size_t *stacksize); Example\nchar stack_area[64 * 1024]; // 64 KB buffer pthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_setstack(\u0026attr, stack_area, sizeof stack_area); void *addr; size_t sz; pthread_attr_getstack(\u0026attr, \u0026addr, \u0026sz); // addr == stack_area, sz == 65536 pthread_attr_destroy(\u0026attr); ","types#Types":""},"title":"_index"}}