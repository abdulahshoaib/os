{"/exec-family/":{"data":{"":"","execl#execl()":"execl() Replaces current process with a new one using a path and a list of arguments\nint execl(const char *path, const char *arg, ..); Return Value:\nSuccess: No return Error: -1 ","execle#execle()":"Like execl() but allows specifying a custom environment\nint execle(const char *path, const char *arg, .., char * const envp[]); Return Value:\nSuccess: No return Error: -1 ","execlp#execlp()":"Like execl() but searches PATH for the executable\nint execlp(const char *file, const char *arg, ..); Return Value:\nSuccess: No return Error: -1 ","execv#execv()":"Replaces current process using a path and an argument vector (array)\nint execv(const char *path, char *const argv[]); Return Value:\nSuccess: No return Error: -1 ","execvp#execvp()":"Like execv() but searches PATH for the executable\nint execvp(const char *file, char *const argv[]); Return Value:\nSuccess: No return Error: -1 ","execvpe#execvpe()":"Like execvp() but also allows specifying a custom environment\nint execvpe(const char *file, char *const argv[], char *const envp[]); Return Value:\nSuccess: No return Error: -1 "},"title":"_index"},"/file-operations/":{"data":{"":"","close#close()":"Closes an open file descriptor.\nint close(int fd); Return Value:\nSuccess: 0 Error: -1 ","dup#dup()":"Duplicates an existing file descriptor to the lowest-numbered unused one.\nint dup(int oldfd); Return Value:\nSuccess: New file descriptor Error: -1 ","dup2#dup2()":"Duplicates a file descriptor to a specified descriptor number, closing it first if needed.\nint dup2(int oldfd, int newfd); Return Value:\nSuccess: New file descriptor Error: -1 ","open#open()":"open() Opens a file and returns a file descriptor for it.\nint open(const char *pathname, int flags, mode_t mode); Return Value:\nSuccess: File descriptor Error: -1 ","read#read()":"Reads data from a file descriptor into a buffer\nssize_t read(int fd, void *buf, size_t count); Return Value:\nSuccess: Number of bytes read Error: -1 ","write#write()":"Writes data from a buffer to a file descriptor.\nssize_t write(int fd, const void *buf, size_t count); Return Value:\nSuccess: Number of bytes written Error: -1 "},"title":"_index"},"/pipes--fifos/":{"data":{"":"","mkfifo#mkfifo()":"Creates a named pipe (FIFO) special file that can be used for inter-process communication\nint mkfifo(const char *pathname, mode_t mode); Return Value:\nSuccess: 0 Error: -1 ","pipe#pipe()":"pipe() Creates a unidirectional data channel (pipe) using a pair of file descriptors for reading and writing\nint pipe(int pipefd[2]); Return Value:\nSuccess: 0 Error: -1 "},"title":"_index"},"/process-control/":{"data":{"":"","_exit#_exit()":"Immediately terminates the process without flushing stdio buffers or calling cleanup handlers.\nvoid _exit(int status); Return Value:\nDoes not return ","exit#exit()":"Terminates the calling process and performs cleanup (e.g., flushes stdio buffers).\nvoid exit(int status); Return Value:\nDoes not return ","fork#fork()":"fork() Creates a new child process by duplicating the calling (parent) process.\npid_t fork(void); Return Value:\nParent: child’s PID (positive) Child: 0 Error: -1 ","macros#MACROS":"WIFEXITED Returns true if the child terminated normally (via exit() or _exit()).\nWIFEXITED(status) Return Value:\nTrue if child terminated normally WEXITSTATUS Returns the exit status code of the child (only valid if WIFEXITED(status) is true).\nWEXITSTATUS(status) Return Value:\nReturn code when WIFEXITED is true WIFSIGNALED Returns true if the child terminated due to an uncaught signal.\nWIFSIGNALED(status) Return Value:\nTrue if child terminated by signal WTERMSIG Returns the signal number that caused the child to terminate (only valid if WIFSIGNALED(status) is true).\nWTERMSIG(status) Return Value:\nSignal number when WIFSIGNALED is true WIFSTOPPED Returns true if the child process is currently stopped, not terminated.\nWIFSTOPPED(status) Return Value:\nTrue if child is stopped WSTOPSIG Returns the signal number that caused the child to stop (only valid if WIFSTOPPED(status) is true).\nWSTOPSIG(status) Return Value:\nSignal number when WIFSTOPPED is true ","wait#wait()":"Suspends execution of the calling process until any of its child processes terminates.\npid_t wait(int *status); Return Value:\nSuccess: PID of terminated child Error: -1 ","waitpid#waitpid()":"Waits for a specific child process or set of children to terminate.\npid_t waitpid(pid_t pid, int *status, int options); Return Value:\nSuccess: PID of child Error: -1 With WNOHANG and no children ready: 0 "},"title":"_index"},"/semaphores/":{"data":{"":"","sem_close#sem_close()":"Closes a named semaphore descriptor without removing the semaphore.\nint sem_close(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 ","sem_destroy#sem_destroy()":"Destroys an unnamed semaphore, freeing associated resources.\nint sem_destroy(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 ","sem_getvalue#sem_getvalue()":"Retrieves the current value of the semaphore.\nint sem_getvalue(sem_t *sem, int *sval); Return Value:\nSuccess: 0 Error: -1 ","sem_init#sem_init()":"Initializes an unnamed semaphore for use within a process or between processes.\nint sem_init(sem_t *sem, int pshared, unsigned int value); Return Value:\nSuccess: 0 Error: -1 ","sem_open#sem_open()":"sem_open() Opens or creates a named semaphore and returns a pointer to it.\nsem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); Return Value:\nSuccess: Pointer to semaphore Error: SEM_FAILED ","sem_post#sem_post()":"Increments (unlocks) the semaphore, potentially waking a waiting thread.\nint sem_post(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 ","sem_trywait#sem_trywait()":"Tries to decrement the semaphore without blocking; fails if the value is zero.\nint sem_trywait(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 ","sem_unlink#sem_unlink()":"Removes a named semaphore from the system\nint sem_unlink(const char *name); Return Value:\nSuccess: 0 Error: -1 ","sem_wait#sem_wait()":"Decrements (locks) the semaphore, blocking if its value is zero.\nint sem_wait(sem_t *sem); Return Value:\nSuccess: 0 Error: -1 "},"title":"_index"},"/shared-memory/":{"data":{"":"","memory-mapping#Memory Mapping":"mmap() Maps a file or anonymous memory into the process’s address space\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); Return Value:\nSuccess: Pointer to mapped area Error: MAP_FAILED munmap() Unmaps a previously mapped memory region from the address space\nint munmap(void *addr, size_t length); Return Value:\nSuccess: 0 Error: -1 ","semget#semget()":"Creates a new semaphore set or accesses an existing one\nint semget(key_t key, int nsems, int semflg); Return Value:\nSuccess: Semaphore set ID Error: -1 ","semop#semop()":"Performs one or more atomic operations on semaphores\nint semop(int semid, struct sembuf *sops, size_t nsops); Return Value:\nSuccess: 0 Error: -1 ","shmat#shmat()":"Attaches a shared memory segment to the process’s address space\nvoid *shmat(int shmid, const void *shmaddr, int shmflg); Return Value:\nSuccess: Pointer to shared memory segment Error: -1 ","shmctl#shmctl()":"Performs control operations on a shared memory segment (eg., remove, get info).\nint shmctl(int shmid, int cmd, struct shmid_ds *buf); Return Value:\nSuccess: 0 Error: -1 ","shmdt#shmdt()":"Detaches a shared memory segment from the process’s address space\nint shmdt(const void *shmaddr); Return Value:\nSuccess: 0 Error: -1 ","shmget#shmget()":"shmget() Allocates or accesses a shared memory segment using a key\nint shmget(key_t key, size_t size, int shmflg); Return Value:\nSuccess: Shared memory segment ID Error: -1 "},"title":"_index"},"/threading/":{"data":{"":"","pthread_cond_destroy#pthread_cond_destroy()":"Destroys a condition variable, freeing its resources\nint pthread_cond_destroy(pthread_cond_t *cond); Return Value:\nSuccess: 0 Error: Error number ","pthread_cond_init#pthread_cond_init()":"Initializes a condition variable used for signaling between threads\nint pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr); Return Value:\nSuccess: 0 Error: Error number ","pthread_create#pthread_create()":"pthread_create() Creates a new thread and starts executing the specified routine in parallel\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg); Return Value:\nSuccess: 0 Error: Error number ","pthread_detach#pthread_detach()":"Marks a thread as detached so its resources are automatically released on termination\nint pthread_detach(pthread_t thread); Return Value:\nSuccess: 0 Error: Error number ","pthread_exit#pthread_exit()":"Terminates the calling thread and optionally returns a value to any joining thread\nvoid pthread_exit(void *retval); Return Value:\nDoes not return ","pthread_join#pthread_join()":"Waits for the specified thread to terminate and optionally collects its return value\nint pthread_join(pthread_t thread, void **retval); Return Value:\nSuccess: 0 Error: Error number ","pthread_self#pthread_self()":"Returns the thread ID of the calling thread\npthread_t pthread_self(void); Return Value:\nThe ID of the calling thread "},"title":"_index"}}